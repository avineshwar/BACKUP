#!/bin/sh


### IMPORTANT NOTES ###
# THE MINIMUM OUPTPUT WHICH THE USER ALWAYS RECEIVES IS THE VOLUME-ID OF THE BACKUP VOLUME.
# IF VERBOSE FLAG IS NOT SET, OUTPUT HAS TO BE DISPLAYED ONLY POST SCRIPT EXECUTION.
# NO USER INTERACTION IS ALLOWED. IT IS A ONE-SHOT SCRIPT.
# NO ENVIRONMENT VARIABLE WILL BE SET FROM THIS SCRIPT.
# USE "sed" TO EXTRACT THE REQUIRED INFO FROM "dmesg | tail"
# IF WE ARE SUPPRESSING OUTPUTS, IT IS A GOOD PRACTISE TO EXECUTE "echo $?" AT LEAST AT CRUCIAL PLACES
# AND IF IT RETURNS 0, THEN WE CAN MOVE FORWARD OR ELSE BREAK THE SCRIPT.
# COMMANDS SHOULD BE OUTPUT SUPPRESSIVE, PRIMARILY. WE CAN OPT OUT ANYTIME. IMPORTANT.


# SET VARIABLES
flag_verbose=$EC2_BACKUP_VERBOSE
flag_key=$EC2_BACKUP_FLAGS_SSH
flag_instance_type=$EC2_BACKUP_AWS
# THEIR VALUES WILL BE PICKED UP FROM USER'S ENVIRONMENT.
# WHAT IF IT IS NOT SET? WE NEED EQUIVALENT REPLACEMENT TO MAKE THE COMMAND GO THROUGH.

#SSH_FLAG='-i ~/ec2key1.pem' # Set to whatever ec2 key


################## CREATE THE BACKUP VOLUME ###################

backup_volume_size=`du -s path_by_user 2>/dev/null | cut -f1`
backup_volume_size=`echo $(($backup_volume_size * 2))`
backup_volume_size=`echo $(($backup_volume_size / 1024))`
backup_volume_size=`echo $(($backup_volume_size / 1024))`
backup_volume_size=`echo $(($backup_volume_size + 1))`
# "path_by_user" SHOULD BE SET WHEN USER EXECUTES THE SCRIPT.
# FIXTURE NEEDED FOR SIZES. THEY CAN BE IN MBs OR GBs.
# MUST BE AT LEAST TWICE THE SIZE OF THE DIRECTORY TO BE BACKED UP.

# ZONE IS NOT NEEDED. SCRIPT IS GOING TO BE EXECUTED IN SOME ZONE WHERE THE USER IS ALREADY EXISTING.
#zone='us-east-1c'

## EVERYTHING RELATED TO INSTANCE AND VOLUME CREATION
# I THINK KEY IS ASSUMED TO BE PRESENT ALREADY IN $EC2_BACKUP_FLAGS_SSH.
# ASSUMING THAT EC2_BACKUP_FLAGS_SSH IS HAVING THE FORM OF MANUAL, THIS WILL HELP US,
# key=`echo $EC2_BACKUP_FLAGS_SSH | cut -d / -f3`
# IT WILL RETURN $KEY AS "ec2-key" 
# OUR TOOL IS ASSUMING THAT OUR USER IS READY TO DEPLOY ANY INSTANCE SINCE HE IS ALREADY HAVING
# HIS KEY AND SECURITY GROUP READY, HOWEVER, THERE WAS NO DESCRIPTION ABOUT SECURITY GROUP.
# LET'S JUST CREATE THAT.

aws ec2 create-security-group --group-name mysecuritygroup --description "Backup group" > /dev/null && aws ec2 authorize-security-group-ingress --group-name mysecuritygroup --port 22 --protocol tcp --cidr 0.0.0.0/0 > /dev/null

# WE CAN ALLOW A CIDR-BASED ACCESS TO THE USER AFTER ANALYZING HIS IP FROM IFCONFIG.
# SECURITY GROUP NAMES CAN COLLIDE AND HENCE "echo ?$" IS NECESSARY BEFORE PROCEEDING.

availability_zone=`aws ec2 run-instances --image-id ami-569ed93c --key-name $key --security-groups mysecuritygroup --count 1 $EC2_BACKUP_AWS | egrep -o 'us-.{6,7}|eu-.{6,10}|ap-.{11,12}|sa-.{6,7}'`

# "availability_zone" WILL STORE THE REGION WHERE WE WILL CREATE OUR INSTANCE.

# CREATE A VOLUME IN $availability_zone OF $backup_volume_size AND ATTACH IT TO THAT SPECIFIC INSTANCE
# WHICH WAS CREATED. HOW WILL THAT INSTANCE BE IDENTIFIED WHEN WE ARE NOT CREATING THE KEY AND OUTPUT
# IS NOT ALLOWED TO BE DISPLAYED? I DOUBT SOME EPIC GREPING MIGHT BE NEEDED OR MAYBE $availability_zone
# SHOULD BE DELAYED FOR A WHILE BECAUSE WE WILL NEED IT TO ATTACH A VOLUME TO AN INSTANCE, HOWEVER, IF
# WE CHOOSE TO DO SO, WE WILL NOT BE ABLE TO CREATE A VOLUME UNTIL WE KNOW OUR AVAILABILITY ZONE INFO. 


# A CRUCIAL FACT SAYS THAT IF A VOLUME WAS CREATED, IT MIGHT HAVE BEEN DONE WITH RESPECT TO SOME
# PARTICULAR AVAILABILITY ZONE AND SINCE THE USER IS CREATING THAT, WE ASSUME HE MIGHT HAVE CREATED
# THAT IN HIS AVAILABILITY ZONE. IF THE VOLUME IS NOT ON THE SAME ZONE IN WHICH WE ARE GOING TO CREATED
# A NEW INSTANCE, THAT VOLUME CANNOT BE MOUNTED ON THAT INSTANCE. ALTERNATIVELY, WE NEED TO MODIFY THE
# AWS CONFIGURE FOR THE REGION PART TO MAKE IT WORK. THAT DOES NOT SOUND TOO GOOD.

# CONTINUE FROM HERE. GOODNIGHT.

#### I HAVE NOT CHECKED BELOW THIS.. ###
#- AVINESHWAR.


#volume=`aws ec2 create-volume -s $backup_volume_size $zone | cut -f6` # EC2 COMMANDS ARENT ALWAYS IN /usr/bin better to use EC2_HOME

################## SETUP THE BACKUP INSTANCE ###################

# Determine kernel type of the local machine
kernel="Ubuntu"
# Create an instance with the same kernel type as the local machine
imageID="ami-0ccb7d64" # for Ubuntu 14.04
instanceID='aws ec2 run-instances --instance-type t1.micro --security-groups admin --key-name ec2key1 --image-id imageID | grep INSTANCES | cut -f8' 
# Enter wait loop while instance is spooling
state=''
while[ "$state" != "running" ]  
do
	state='aws ec2 describe-instances --instance-id $instanceID | grep STATE | cut -f3'
done
# Determine the instance address for logging in
domain='aws ec2 describe-instances --instance-id $instanceID | grep ASSOCIATION | cut -f3 | awk 'NR==1{print $1}''
# Attach volume to instance
deviceID='/dev/sdx'
aws ec2 attach-volume --instance-id "$instanceID" --volume-id "$volume" --device "$deviceID"
# Enter wait loop while volume is attaching
state=''
while[ "$state" != "attached" ]  
do
	state='aws ec2 describe-volumes --volume-id "$volume" | grep ATTACHMENTS | cut -f6'
done
# Create Mount point
mountPoint='/mnt/backup' #directory to mount backup volume
ssh "$SSH_FLAG" -o StrictHostKeyChecking=no ubuntu@"$domain" sudo mkdir $mountPoint


# format volume
# Log out of instance

################## BACKUP FILES ###################
